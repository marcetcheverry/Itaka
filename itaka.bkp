#! /usr/bin/env python
# -*- coding: utf8 -*-
# Itaka Screenshooting Server (Twisted+GTK2) (Windows/Linux)
"""TODO:
Agregar: Agregar ConfigParser y os.specific (ver papel)
	http://www.python.org/doc/lib/ConfigParser-objects.html (Usar dict )
	Finalizar menu de Trayicon
	Usar bindings de python libnotify http://ptlo.blogspot.com/2005/11/missing-piece.html
	Rediseñar dialgoo de preferencias con gtk.table
	Agregar preferencia de Start minimized
	Usar más traceback
	Arreglar FIXME y limpiar codigo, sintaxis y funciones

	Usar setup.py
	Win32: Usar el tray de ellos, Usar su notif bubbles
	http://www.pycode.com/modules/?id=2&tab=download&PHPSESSID=c64279880833ecf64f6520967786d1fc
	http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/334779

	*** Arreglar bug de FTP loop ***
	*** Agregar threading a FTP ***
	
Linux UI: +HIG. Glade? 
"""
import sys, os, gc, datetime, traceback, ftplib, threading, Queue, time

# FIXME: Add checking
from twisted.internet import gtk2reactor
gtk2reactor.install()

from twisted.python import log
from twisted.web import server, static
from twisted.web.resource import Resource
from twisted.internet import reactor

# Import GTK+
try:
	import pygtk
	pygtk.require("2.0")
except ImportError:
	print "[*] WARNING: Pygtk module is missing."
        pass
try:
        import gtk, gobject
except ImportError:
	print "[*] ERROR: GTK+ Python bindings are missing."
	sys.exit(1)

try:
	from egg import trayicon
	trayiconSupport = True
except ImportError:
	print "[*] WARNING: GTK+ Python TrayIcon bindings are missing, disabling trayicon."
	trayiconSupport = False
	pass

# Import itaka dependencies
#try:
#	from modules import itaka_globals as iglobals
#except ImportError:
#	print "[*] WARNING: Failed loading itaka_globals module, setting manually."
#	""" Workaround for setting variables manually. """
#	class iglobals: pass
#	
#	setattr(iglobals, 'version', 'Devel')
#	
#	""" $currentdir/images is the fallback dir """
#	if (os.path.exists(os.path.join(os.getcwd(),'images'))):
#		setattr(iglobals, 'image_dir', os.path.join(os.getcwd(),'images'))
#	else:	
#		print "[*] ERROR: Could not find images. "
#		sys.exit(1)
#	# Just to be safe (local instance of itaka_globals)
#	sys.modules["itaka_globals"] = iglobals

# Set up global itaka variables
iversion = "Devel"
# See what system we are running on posix/nt
isystem = os.name
# Where itaka images are stored.. FIXME
image_dir = os.path.join(sys.path[0], "images/")
# Counter, do not change.
icserved = 0
# Method (ftp, server)
imethod = "server"
# FTP Variables
iftphost = "ftp.usuarios.lycos.es"
iftpport = 21
iftpuser = "cgarcia2003"
iftppass = "infest"
iftpupdir = "/"
# Time in milliseconds (multiply by a thousand)
iftptime = 8000

# TCP port
iport = 8000
# Path to the Screenshot FIXME:Config
ipath = '/tmp'
if (isystem != 'posix'):
	# FIXME find TEMP with windows ENV Variables
	ipath = os.getcwd()
# Image format: 'jpeg' or 'png'
iformat = 'jpeg'
# Image quality: integer 0 to 100.
iquality = 65
# Alert on request (bell)
ialert = True
# Audio Player support: True/False
# FIXME: Actually starts rhytmbox wehna called
iaudio = False
# Libnotify support
inotify = True

# Customization of HTML
if (iaudio): 
	# This is the Audio player HTML.
	iaudiohtml = '<iframe src="audio" width="100%" height="30" style="border: 0;" border="0">Your browser does not support IFRAME. <a href="audio">Click herek</a></iframe><br />'
else:	iaudiohtml = '' 

# This is the HTML that will be displayed
ihtml = '<html><body> ' + iaudiohtml  + ' <img src="screenshot" alt="If you are seeing this message it means there was an error in Itaka or you are using a text-only browser." border="0"></a></body</html>'

# Do not change anything below this
if (iaudio):
	import dbus	
	bus = dbus.SessionBus()
	rbshellobj = bus.get_object('org.gnome.Rhythmbox', '/org/gnome/Rhythmbox/Shell')
	rbshell = dbus.Interface(rbshellobj, 'org.gnome.Rhythmbox.Shell')
	rbplayerobj = bus.get_object('org.gnome.Rhythmbox', '/org/gnome/Rhythmbox/Player')
	rbplayer = dbus.Interface(rbplayerobj, 'org.gnome.Rhythmbox.Player')
	rburi = rbplayer.getPlayingUri()

class AudioResource(Resource):
	""" Get the current playing song. """
	def getAudiodata(self):
		""" This class should return a string with what you
		want the Now Listening: tag to display. """
		self.playing = rbplayer.getPlayingUri().replace('%20', ' ').replace('file://', '').replace('%F1', 'n').replace('%E9', 'e').replace('%C3%AD', 'i').replace('%C3%A9', 'e')
		#self.playing = urllib.unquote(rbplayer.getPlayingUri())
		return self.playing
	
	def render_GET(self, request):
		""" Handle GET requests for audio.html. """
		request.setHeader("Content-type", "text/html; charset=UTF-8'")
		self.getAudiodata()
		#igui.talk('updateSongStatus', str(self.playingi), None)
		return "<strong>Escuchando: %s.</strong>" % (str(self.playing))
		
# Set up the screenshooter server
class ImageResource(Resource):
	""" Take the screenshot code and handle the requests. """
	# Screenshot request handler
	def getScreenshot(self):
		""" Takes a screenshot and returns it. """
		self.shot = 'image.' + iformat
		w = gtk.gdk.screen_width()
		h = gtk.gdk.screen_height()
		screenshot = gtk.gdk.Pixbuf.get_from_drawable(
			gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, w, h),
			gtk.gdk.get_default_root_window(),
			gtk.gdk.colormap_get_system(),
			0, 0, 0, 0, w, h)
		self.shotFile = os.path.join(ipath,self.shot)
        	screenshot.save(self.shotFile, self.shot.split('.')[1], {"quality":str(iquality)})

		# Important woraround to avoids a memory leak. Do *NOT* edit
		# http://www.async.com.br/faq/pygtk/index.py?req=show&file=faq08.004.htp
		del screenshot
		gc.collect()

		return self.shotFile
	
	def render_GET(self, request):
		""" Handle GET requests for screenshot. """
		request.setHeader("Content-type", "image/" + iformat)
		self.icip = request.getClientIP()
		self.time = datetime.datetime.now()
		# self.icbrowser = request.getClient()

		self.getScreenshot()
		global icserved
		icserved += 1
		# Call libnotify manually FIXME
		if (inotify): 
			self.notifyseq = ["notifyit", str(self.icip), str(icserved)]
			self.notifyinstance = gobject.spawn_async(self.notifyseq, flags=gobject.SPAWN_SEARCH_PATH)
				
		#os.system('notifyit "' + str(self.icip) + '" "' + str(icserved)+ '"')
		# Tell the GUI what changed
		igui.talk('updateGuiStatus', str(icserved), str(self.icip), self.time)

		return open(self.shotFile, 'rb').read()		

class Console:
	""" Handle Console input and logging output organized by message clas. """
	def __init__(self):
		""" Init the console handler. """
		# sys.path[0] is bogus machonus
		print "[*] Itaka (%s) %s starting up..." % (os.path.join(os.getcwd(),os.path.basename(__file__)), iversion)
		
	def __del__(self):
		""" Destructor. """
		print "[*] Itaka shutting down..."
		
	def msg(self, message, gui=False):
		""" Message handler. """
		# FIXME add try
		#if gui: igui.logger(['message', message])
		print "[*] %s" % (message)
		
	def warn(self, caller, message):
		""" Warning handler. """
		self.array = ".".join(caller)
		print "[*] WARNING: %s: %s" % (self.array, message)
		
	def debug(self, caller, message):
		""" Debug handler. """
		self.array = ".".join(caller)
		print "[*] DEBUG: %s: %s" % (self.array, message)

	def error(self, caller, message):
		""" Error handler. """
		self.array = ".".join(caller)
		print "[*] ERROR: %s: %s" % (self.array, message)
		
class Ftp(threading.Thread):
	""" Threaded FTP backbend. """
	def __init__(self, queue):
		self.queue = queue
		self.done = False
		threading.Thread.__init__(self)
		self.setDaemon(1)
		
	def stop(self):
		""" This stops the thread. """
		try:
			self.ftp.abort()
			self.ftp.quit()
		except error_proto, error_replyr:
			pass
		self.done = True
		print "Done"
		
	def run(self):
		""" This handles the thread queue. """
        	while not self.done:
            		self.item = self.queue.get()
            		if self.item is None:
                	    self.cout.msg("Nothing to do")
                	    self.done = True
               		    break
		    	self.upload(self.item)

	def upload(self, args):
		""" Set up a ftplib instance and upload. """
		# Dont ask about this. Fix it, motherfucker.
		# args = "host@port@username@password@updir"
		type(args)
		self.iftpconf = str(args).split('@')

		# Get the Console instance from the GUI
		self.cout = igui.cout
		self.ftp = ftplib.FTP()
		self.ftp.connect(self.iftpconf[0], self.iftpconf[1])
		# Log to gui also
		self.cout.msg("Connecting to %s:%s..." % (self.iftpconf[0], self.iftpconf[1]), True)
		self.cout.msg(self.ftp.getwelcome(), True)
		try:
		  try:
			self.ftp.login(self.iftpconf[2], self.iftpconf[3])
			# FIXME: Add self.ftp.mkd
			if self.iftpconf[-1]:
	    			self.ftp.cwd(self.iftpconf[-1])
	    		self.cout.msg("Currently in: %s" % (self.ftp.pwd()), True)
			# Take the screenshot
			self.ftpscreen = ImageResource().getScreenshot()
	    		self.cout.msg("Uploading: %s..." % (self.ftpscreen), True)
	    		if (os.path.exists(self.ftpscreen)):
	    			file = open(self.ftpscreen, "rb")
				try:
					# Thread..
					try:
						self.ftp.storbinary('STOR ' + str(self.ftpscreen).split('/')[-1], file)
					except AttributeError:
						pass
					# FIXME: Agregar nueva funcion
					self.time = datetime.datetime.now()
					
					# Tell the gui
					global icserved
					icserved += 1
					
  	    				self.cout.msg("Screenshot " + str(icserved) + " uploaded",  True)
					
					igui.talk('updateGuiStatus', str(icserved), None, self.time)
				except:
					traceback.print_exc()
 	    			file.close()
			else:
				self.ftp.quit()
				self.cout.msg("Cant find %s" % (screenshot))
		  finally:
	    		self.cout.msg("Closing connection to server... Wait %s" % (str(iftptime / 1000)))
  	    		self.ftp.quit()
        	except:
 	  		self.cout.msg("Terminated prematurely.")
			#traceback.print_exc()

class Gui:
    def __init__(self):
	if (imethod == 'server'):
		self.root = static.Data(ihtml, 'text/html; charset=UTF-8')
		""" Registers an identitiy (resource, file)
		as putcChild('name', HandlerClass()). """
		if (iaudio): self.root.putChild('audio', AudioResource())	
        	self.root.putChild('screenshot', ImageResource())
        	self.root.putChild('', self.root)
	
        # Set up main GUI
        self.icon_pixbuf = gtk.gdk.pixbuf_new_from_file(os.path.join(image_dir, "itaka.png"))
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.connect("destroy", self.destroy)
        self.window.set_title("Itaka")
        self.window.set_icon(self.icon_pixbuf)
        self.window.set_border_width(6)
        self.window.resize(500, 1)
        self.window.set_position(gtk.WIN_POS_CENTER)

	if (trayiconSupport):
        	# Set up TrayIcon
		self.menu = gtk.Menu()
        	self.itray = trayicon.TrayIcon("Itaka")
        	self.itraylogobox = gtk.EventBox()
            	# Build the menu FIXME
		self.menu = gtk.Menu()
		self.menuabout = gtk.MenuItem("About")
		self.menuprefs = gtk.MenuItem("Preferences")
		self.menustop = gtk.MenuItem("Stop")
		self.menustart = gtk.MenuItem("Start")
		self.menuquit = gtk.MenuItem("Quit")

		self.menu.append(self.menuabout)
		self.menu.append(self.menuprefs)
		self.menu.append(self.menustop)	
		self.menu.append(self.menustart)
		self.menu.append(self.menuquit)
		
		self.menustart.connect("activate", self.startstop, "Start")
		self.menustop.connect("activate", self.startstop, "Stop")
		self.menuprefs.connect("activate", self.preferences)
		self.menuabout.connect("activate", self.about)
		self.menuquit.connect("activate", self.destroy)
		
		# Showing off
		for f in (self.menuquit, self.menustop, self.menustart, self.menuprefs, self.menuabout):
				f.show()

      	self.itraylogo = gtk.Image()
       	self.itraylogo.set_from_pixbuf(gtk.gdk.pixbuf_new_from_file(os.path.join(image_dir, "itaka.png")).scale_simple(20, 20,gtk.gdk.INTERP_BILINEAR))
        self.itraylogobox.add(self.itraylogo)
       	self.itraylogobox.connect("button_press_event", self.trayclicked)

        # Boxes, images, and buttons
        self.vbox = gtk.VBox(False, 6)
        self.box = gtk.HBox(False, 0)

        self.itakaLogo = gtk.Image()
        self.itakaLogo.set_from_file(os.path.join(image_dir, "itaka.png"))
        self.itakaLogo.show()

	# Add hbox and buttons and image
        self.box.pack_start(self.itakaLogo, True, True, 4)


        self.ibox = gtk.HBox(False, 0)
        self.buttonStartstop = gtk.ToggleButton("Start", gtk.STOCK_PREFERENCES)
        self.startstopimage = gtk.Image()

        self.startstopimage.set_from_stock(gtk.STOCK_EXECUTE, gtk.ICON_SIZE_BUTTON)
        self.buttonStartstop.set_image(self.startstopimage)
        self.buttonStartstop.connect("toggled", self.startstop, "Start/Stop button")
        self.ibox.pack_start(self.buttonStartstop, True, True, 8)

        # Preferences button
        self.preferencesButton = gtk.Button("Preferences", gtk.STOCK_PREFERENCES)
        self.preferencesButton.connect("clicked", self.preferences, "Preferences button")
        self.ibox.pack_start(self.preferencesButton, True, True, 4)

        self.box.pack_start(self.ibox, True, True, 0)
        self.vbox.pack_start(self.box, False, False, 0)

        # Another Hbox and Labels
        self.statusBox = gtk.HBox(False, 0)
        self.labelServed = gtk.Label()
        self.labelLastip = gtk.Label()
	self.labelTime = gtk.Label()

        self.statusBox.pack_start(self.labelLastip, True, False, 0)
        self.statusBox.pack_start(self.labelTime, True, False, 0)
        self.statusBox.pack_start(self.labelServed, True, False, 0)

        # Logger widget (displayed when expanded)
        self.debugvbox = gtk.VBox(False, 0)
        self.debugscroll = gtk.ScrolledWindow()
        self.debugscroll.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        self.debugscroll.set_shadow_type(gtk.SHADOW_IN)
        self.debugview = gtk.TextView()
        self.debugview.set_wrap_mode(gtk.WRAP_WORD)
	self.debugview.set_editable(False)
        self.debugview.set_size_request(-1, 160)
        self.debugbuffer = self.debugview.get_buffer()
        self.debugscroll.add(self.debugview)

        # Buttons
        self.debughbox = gtk.HBox(False, 0)
        self.debugclearbutton = gtk.Button("Clear")
        self.debugclearbuttonimage = gtk.Image()
        self.debugclearbuttonimage.set_from_stock(gtk.STOCK_CLEAR, gtk.ICON_SIZE_BUTTON)
        self.debugclearbutton.set_image(self.debugclearbuttonimage)
        self.debugclearbutton.connect("clicked", self.clearlogger)

        self.debugpausebutton = gtk.ToggleButton("Pause")
        self.debugpausebuttonimage = gtk.Image()
        self.debugpausebuttonimage.set_from_stock(gtk.STOCK_MEDIA_PAUSE, gtk.ICON_SIZE_BUTTON)
        self.debugpausebutton.set_image(self.debugpausebuttonimage)
        self.debugpausebutton.connect("toggled", self.pauselogger)

        # Reverse?
        self.debughbox.pack_end(self.debugclearbutton, False, False, 4)
        self.debughbox.pack_end(self.debugpausebutton, False, False, 4)

        # Pack it all into a nice vbox
        self.debugvbox.pack_start(self.debugscroll, False, False, 4)
        self.debugvbox.pack_start(self.debughbox, False, False, 4)

        # Label for the expander
        self.debugboxLabel = gtk.Label("<b>Detailed log</b>")
        self.debugboxLabel.set_use_markup(True)

        # Expander
        self.expander = gtk.Expander(None)
        self.expander.set_label_widget(self.debugboxLabel)
        self.expander.connect('notify::expanded', self.expandlogger)

        # Log to the self.logger function, which sets the buffer for self.debubuffer
        log.addObserver(self.logger)

        # Add to main vbox
        self.vbox.pack_start(self.statusBox, False, False, 4)
        self.vbox.pack_start(self.expander, False, False, 0)
	self.expander.set_sensitive(False)
        # Add vbox to window (parent adds all)
        self.window.add(self.vbox)

        # Show window & tray
        self.window.show_all()
	if (trayiconSupport):
		self.itray.add(self.itraylogobox)
        	self.itray.show_all()

    def expandlogger(self, expander, params):
        """ Callback for the expander widget. """
        if self.expander.get_expanded():
            # Show the debugvbox() and it's subwidgets
            self.debugvbox.show_all()
            self.expander.add(self.debugvbox)
        else:
            self.expander.remove(self.expander.child)
            self.window.resize(500, 1)
        return

    def logger(self, args):
        """ Handle logging in the GUI. """
        # Write out the server log and stdout to the GUI
        self.ioutput = args['message'][0]
        self.debugbuffer.insert_at_cursor("\r" +self.ioutput,len("\r" + self.ioutput))
        # Automatically scroll. We use wrap because I cant fix this.
        self.debugview.scroll_mark_onscreen(self.debugbuffer.get_insert())

    def clearlogger(self, args):
        """ Callback to clear the log. """
        self.debugbuffer.set_text("")

    def pauselogger(self, widget, data=None):
        """ Callback to pause the log. """
        if widget.get_active():
            log.msg("Logging paused.")
            log.removeObserver(self.logger)
        else:
            log.addObserver(self.logger)
            log.msg("Logging started.")

    def main(self):
        """ Init sequence that starts the GTK+ (twisted) reactor. """
        # GTK Reactor and Console Handling
	try:
        	self.cout = Console()
	except AttributeError:
		print "[*] ERROR: Console()"
		traceback.print_exc()
		sys.exit(1)
        self.greact = reactor.run()

    def traymenu(self):
        """ Create the trayicon menu. """
        self.cout.debug(["Gui", "traymenu"], "called menu build")
	self.menu.popup(mone,None,None,event.button,event.time)
	
    def about(self, data=None):
	self.about = gtk.AboutDialog()
	self.about.set_name('Itaka')
	self.about.set_version(iversion)
	self.about.set_copyright(u'© 2003-2006 Marc Etcheverry')
	self.about.set_comments('Screenshooting de mercado.')
	self.about.set_authors(['Marc Etcheverry <m4rccd@yahoo.com>'])
	self.about.set_website('http://itaka.sourceforge.net')
	self.about.set_logo(gtk.gdk.pixbuf_new_from_file(os.path.join(image_dir, "itaka.png")))
	self.about.set_icon(self.icon_pixbuf)
	self.about.show()

    def trayclicked(self, widget, event):
        """ Handle the clicks on the trayicon. """
        self.iwstatus = self.window.get_property("visible")
        if event.type == gtk.gdk.BUTTON_PRESS and event.button == 1:
            # FIXME: Find a real func instead of workaround to see if window is hidden/showing.
            if (self.iwstatus):
                self.window.hide()
            else:
                self.window.show()
                self.window.set_position(gtk.WIN_POS_CENTER)
	elif event.button == 2:
	    self.about()
	else:
        # Create menu
	    self.menu.popup(None,None,None,event.button,event.time)
	

    def checkwidget(self, widget):
	    """ Workaround to save code on menu/main startstop. """
	    if hasattr(widget, 'get_active'):
		    return widget.get_active()
	    else:
		    return False

    def startstop(self, widget, data=None):
        """ Start or stop the screenshooting server from window or menu. """
	""" FIXME: This is a very complex function that needs
	to be rewritten to something *acceptable* """
	
	if ( self.checkwidget(widget) or data == "Start"):
	    # Workaround to avoid collision between
	    # setting startstopbutton.set_active and 
	    # already started server from the menu, 
	    # and viceversa.
	    if (imethod == 'server'):
	    	if (hasattr(self, 'ilistener')):
			return True
	    else:
		if (hasattr(self, 'ftprunning')):
			pass
	    if (imethod == 'server'):
            		# Start up the twisted site
            		self.site = server.Site(self.root)
            		# Start Server reactor. Make an instance to distinguish from self.greactor().
            		self.ilistener = reactor.listenTCP(iport, self.site)
			if (data):
		    		self.buttonStartstop.set_active(True)

	    else:
		    
			# Start up the FTP upload sequence
	    		#self.ftpinstance = Ftp()
			#self.ftpinstance.start(iftphost, iftpport, iftpuser, iftppass, iftpupdir)
			#self.ftprunning = gobject.timeout_add(20000, self.ftpinstance.start, iftphost, iftpport, iftpuser, iftppass, iftpupdir)
			job_q = Queue.Queue()
			self.ftprunning = Ftp(job_q)
			self.ftprunning.start()
			job_q.put("%s@%s@%s@%s@%s" % (iftphost, iftpport, iftpuser, iftppass, iftpupdir))
			
	   	 	# If called from tray, set the main button active
	    		if (data):
		    		self.buttonStartstop.set_active(True)
	    
            	# Announce on log y console stdout
	    if (imethod == 'server'):
	            	self.cout.msg('Server listening on port ' + str(iport) + ' TCP. Serving screenshots as ' + iformat.upper() + ' images with ' + str(iquality) + '% quality.', True)
	    else:
			self.cout.msg('FTP upload sequence to %s:%s started every %s seconds. Uploading screenshots as %s images' % (str(iftphost), str(iftpport), str(iftptime / 1000), iformat.upper()), True)
			
            # Change buttons
            self.buttonStartstop.set_label("Stop")
            self.startstopimage.set_from_stock(gtk.STOCK_STOP, gtk.ICON_SIZE_BUTTON)
            self.buttonStartstop.set_image(self.startstopimage)
            	
	    # Close the expander
	    self.expander.set_sensitive(True)
	    if inotify:
		    self.itakaLogo.set_from_file(os.path.join(image_dir, "itaka-take.png"))

        else:
	    if (imethod == 'server'):
	    	if hasattr(self, 'ilistener'):
            		log.msg('Itaka shutting down...')
            		self.cout.msg('Server shutting down...')
            		self.ilistener.stopListening()
	    		del self.ilistener
	    		# Stop the g_timeout
	    		if hasattr(self, 'iagotimer'):
				gobject.source_remove(self.iagotimer)
	        	if (data):
		    		self.buttonStartstop.set_active(False)
			self.startstopimage.set_from_stock(gtk.STOCK_EXECUTE, gtk.ICON_SIZE_BUTTON)
            		self.buttonStartstop.set_image(self.startstopimage)
            		self.buttonStartstop.set_label("Start")
	    		
			# Change the labels and expander
			self.labelLastip.set_text('')
	    		self.labelTime.set_text('')
	   	 	self.labelServed.set_text('')
        		self.expander.set_expanded(False)				
	    		self.expander.set_sensitive(False)
	    		self.itakaLogo.set_from_file(os.path.join(image_dir, "itaka.png"))

		else:
			pass
	    else:
		if hasattr(self, 'ftprunning'):
            		self.cout.msg('Stopping FTP sequence...', True)
		#	gobject.source_remove(self.ftprunning)
			self.ftprunning.stop()
			if hasattr(self, 'iagotimer'):
				gobject.source_remove(self.iagotimer)
	        	if (data):
		    		self.buttonStartstop.set_active(False)
			self.startstopimage.set_from_stock(gtk.STOCK_EXECUTE, gtk.ICON_SIZE_BUTTON)
            		self.buttonStartstop.set_image(self.startstopimage)
			print "Set label start"
            		self.buttonStartstop.set_label("Start")
	    	
			# Change the labels and expander
			self.labelLastip.set_text('')
	    		self.labelTime.set_text('')
	    		self.labelServed.set_text('')
        		self.expander.set_expanded(False)				
	    		self.expander.set_sensitive(False)
	    		self.itakaLogo.set_from_file(os.path.join(image_dir, "itaka.png"))


		else:
			pass
	    pass

    def preferences(self, widget, data=None):
        """ Set up the preferences window. """
        self.preferences = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.preferences.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_DIALOG)
        self.preferences.connect("destroy", lambda call: self.preferences.hide())
        self.preferences.set_title("Preferences")
        self.preferences.set_icon(self.icon_pixbuf)
        self.preferences.set_border_width(12)
        self.preferencesVBox = gtk.VBox(False, 0)

        # Create the nine hboxes of the apocalypse.
        self.preferencesHBox1 = gtk.HBox(False, 0)
        self.preferencesHBox2 = gtk.HBox(False, 0)
        self.preferencesHBox3 = gtk.HBox(False, 0)
        self.preferencesHBox4 = gtk.HBox(False, 0)
        self.preferencesHBox5 = gtk.HBox(False, 0)
        self.preferencesHBox6 = gtk.HBox(False, 0)
        self.preferencesHBox7 = gtk.HBox(False, 0)
        self.preferencesHBox8 = gtk.HBox(False, 0)
        self.preferencesHBox9 = gtk.HBox(False, 0)

        # Widgets
        # Section labels
        self.preferencesLabelbackbend = gtk.Label("<b>Backbend</b>")
        self.preferencesLabelbackbend.set_use_markup(True)
        self.preferencesLabelbackbend.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabelbackbend.set_alignment(0.03, 0.50)

        self.preferencesLabelscreenshots = gtk.Label("<b>Screenshooting method</b>")
        self.preferencesLabelscreenshots.set_use_markup(True)
        self.preferencesLabelscreenshots.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabelscreenshots.set_alignment(0.03, 0.50)
        # Labels for input
        self.preferencesLabeltype = gtk.Label("Type:")
        self.preferencesLabeltype.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabeltype.set_alignment(0, 0.50)
        self.preferencesLabelport = gtk.Label("Port:")
        # Return the image
        self.preferencesLabelport.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabelport.set_alignment(0, 0.50)
        self.preferencesLabelhost = gtk.Label("Host:")
        self.preferencesLabelhost.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabelhost.set_alignment(0, 0.50)
        self.preferencesLabelusername = gtk.Label("Username:")
        self.preferencesLabelusername.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabelusername.set_alignment(0, 0.50)
        self.preferencesLabelpassword = gtk.Label("Password:")
        self.preferencesLabelpassword.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabelpassword.set_alignment(0, 0.50)
        self.preferencesLabeltime = gtk.Label("Time:")
        self.preferencesLabeltime.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabeltime.set_alignment(0, 0.50)
        self.preferencesLabelseconds = gtk.Label("seconds")
        self.preferencesLabelamount = gtk.Label("Amount:")
        self.preferencesLabelamount.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabelamount.set_alignment(0, 0.50)
        self.preferencesLabelmethod = gtk.Label("Method:")
        self.preferencesLabelmethod.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabelmethod.set_alignment(0, 0.50)
        self.preferencesLabelapplication = gtk.Label("Application:")
        self.preferencesLabelapplication.set_justify(gtk.JUSTIFY_LEFT)
        self.preferencesLabelapplication.set_alignment(0, 0.50)

        # Entries
        self.preferencesEntryhost = gtk.Entry()
        self.preferencesEntryusername = gtk.Entry()
        self.preferencesEntrypassword = gtk.Entry()
        self.preferencesEntrypassword.set_visibility(False)
        self.preferencesEntryapplication = gtk.Entry()

        # Spinbuttons (FIXME)
        self.preferencesSpinport = gtk.SpinButton()
        self.preferencesSpinport.set_value(8000)
        #self.preferencesSpinport.set_range(1, 65550)
        self.preferencesSpintime = gtk.SpinButton()
        self.preferencesSpintime.set_value(5)
        #self.preferencesSpintime.set_range(1, 65550)
        self.preferencesSpinamount = gtk.SpinButton()
        #self.preferencesSpinamount.set_range(1, 65550)

        # Combos
        # Using simple method http://www.pygtk.org/pygtk2tutorial/sec-ComboBoxAndComboboxEntry.html
        self.preferencesCombotype = gtk.combo_box_new_text()
        self.preferencesCombotype.append_text("Itaka")
        self.preferencesCombotype.append_text("FTP")
        self.preferencesCombotype.set_active(0)
        self.preferencesCombotype.connect("changed", self.preferencesComboHandler, "Type")

        self.preferencesCombomethod = gtk.combo_box_new_text()
        self.preferencesCombomethod.append_text("GTK+")
        self.preferencesCombomethod.append_text("External")
        self.preferencesCombomethod.set_active(0)
        self.preferencesCombomethod.connect("changed", self.preferencesComboHandler, "Method")

        # Close button
        self.preferencesButtonclose = gtk.Button("Close", gtk.STOCK_CLOSE)
        self.preferencesButtonclose.connect("clicked", lambda wid: self.preferences.hide())

        # Add labels to hboxes
        self.preferencesHBox1.pack_start(self.preferencesLabeltype, False, False, 12)
        self.preferencesHBox2.pack_start(self.preferencesLabelport, False, False, 12)
        self.preferencesHBox3.pack_start(self.preferencesLabelhost, False, False, 12)
        self.preferencesHBox4.pack_start(self.preferencesLabelusername, False, False, 12)
        self.preferencesHBox5.pack_start(self.preferencesLabelpassword, False, False, 12)
        self.preferencesHBox6.pack_start(self.preferencesLabeltime, False, False, 12)
        self.preferencesHBox6.pack_end(self.preferencesLabelseconds, False, False, 12)
        self.preferencesHBox7.pack_start(self.preferencesLabelamount, False, False, 12)
        self.preferencesHBox8.pack_start(self.preferencesLabelmethod, False, False, 12)
        self.preferencesHBox9.pack_start(self.preferencesLabelapplication, False, False, 12)

        # Add entries
        self.preferencesHBox3.pack_start(self.preferencesEntryhost, False, False, 0)
        self.preferencesHBox4.pack_start(self.preferencesEntryusername, False, False, 0)
        self.preferencesHBox5.pack_start(self.preferencesEntrypassword, False, False, 0)
        self.preferencesHBox9.pack_start(self.preferencesEntryapplication, False, False, 0)

        # Add SpinButton
        self.preferencesHBox2.pack_start(self.preferencesSpinport, False, False, 0)
        self.preferencesHBox6.pack_start(self.preferencesSpintime, False, False, 0)
        self.preferencesHBox7.pack_start(self.preferencesSpinamount, False, False, 0)

        # Add combos
        self.preferencesHBox1.pack_start(self.preferencesCombotype, False, False, 0)
        self.preferencesHBox8.pack_start(self.preferencesCombomethod, False, False, 0)

        # Add Hboxes to the Vbox
        self.preferencesVBox.pack_start(self.preferencesLabelbackbend, False, False, 4)
        self.preferencesVBox.pack_start(self.preferencesHBox1, False, False, 0)
        self.preferencesVBox.pack_start(self.preferencesHBox2, False, False, 0)
        self.preferencesVBox.pack_start(self.preferencesHBox3, False, False, 0)
        self.preferencesVBox.pack_start(self.preferencesHBox4, False, False, 0)
        self.preferencesVBox.pack_start(self.preferencesHBox5, False, False, 0)
        self.preferencesVBox.pack_start(self.preferencesHBox6, False, False, 0)
        self.preferencesVBox.pack_start(self.preferencesHBox7, False, False, 0)
        self.preferencesVBox.pack_start(self.preferencesLabelscreenshots, False, False, 4)
        self.preferencesVBox.pack_start(self.preferencesHBox8, False, False, 0)
        self.preferencesVBox.pack_start(self.preferencesHBox9, False, False, 0)

        # Add button
        self.preferencesVBox.pack_end(self.preferencesButtonclose, False, False, 5)

        # Add vbox
        self.preferences.add(self.preferencesVBox)
        self.preferences.show_all()

        # Hide HBoxes that should appear when preferencesComboHandler() tells them to
        self.preferencesHBox9.hide_all()
        self.preferencesHBox3.hide_all()
        self.preferencesHBox4.hide_all()
        self.preferencesHBox5.hide_all()
        self.preferencesHBox6.hide_all()
        self.preferencesHBox7.hide_all()


    def preferencesComboHandler(self, widget, who):
    	
        """ Callback for the ComboBoxes in preferences. """
        # See what it sent us
        if ( who == "Type"):
        # The following codes handles showing the extra boxes
            if ( self.preferencesCombotype.get_active_text() == "FTP"):
                self.preferencesHBox3.show_all()
                self.preferencesHBox4.show_all()
                self.preferencesHBox5.show_all()
                self.preferencesHBox6.show_all()
                self.preferencesHBox7.show_all()
            else:
                self.preferencesHBox3.hide_all()
                self.preferencesHBox4.hide_all()
                self.preferencesHBox5.hide_all()
                self.preferencesHBox6.hide_all()
                self.preferencesHBox7.hide_all()
        elif ( who == "Method"):
            if ( self.preferencesCombomethod.get_active_text() == "External"):
                self.preferencesHBox9.show_all()
            else:
                self.preferencesHBox9.hide_all()
        else:
            self.cout.error(["GUI", "preferencesComboHandler"], "%s argument not recognized %" % (who))

    def destroy(self, *args):
	# FIXME: Cleanup stale screenshot file
        """ Callback for the main window's destroy. """
        # Stop server. Check so it does not complain if close while not running.
        if hasattr(self, 'ilistener'):
            self.cout.msg("Shutting down server...")
            #self.ilistener.stopListening()
	    del self.cout
            gtk.main_quit()

        else:
            #self.cout.warn(["Gui", "destroy"], "Server not listening, not shutting down...")
            # Call __del__ in Console()
            del self.cout
            gtk.main_quit()

    def calcsince(self, stime):
	""" Function to calculate the time difference from the last request to 
	the current time and display it in the GUI. """

	""" Handles all dates well, although if the last request was done a month
	or year ago it will display it as numbers of days. Did not bother to add 
	a check for it, but it should be trivial (compare the number of days to
	the current months, divide it. If > 365, divide also. """
	
	# Change now() for a date tuple to test the date parser
	self.isetdiff = datetime.datetime.now() - stime
	
	# Lets make it a string and split it for easier manipulation
	self.idiff = str(self.isetdiff).split(':')
	
	# Set up singular/plural checks
	self.hour = "hours"
	self.min = "minutes"

	# If an hour passed already
	if ("0" not in self.idiff[0]):
		if (self.idiff[0] == "1"): self.hour = "hour"
		# Remove the 0 prefix
		if ("0" in self.idiff[1][:1]): self.idiff[1] = self.idiff[1][1:]
		if (self.idiff[1] == "1"): self.min = "minute"
		self.labelTime.set_text("Time: %s %s, %s %s ago" % (self.idiff[0], self.hour, self.idiff[1], self.min))
		
	else:
		# Instance as minutes
		self.idiff = self.idiff[1]
		# Remove the 0 prefix
		if ("0" in self.idiff[:1]): self.idiff = self.idiff[1:]
		if (self.idiff == "1"):	self.min = "minute"
        	self.labelTime.set_text("Time: %s %s ago" % (self.idiff, self.min))

	# Need this so it runs more than once. Weird.
	return True

    def notify(self):
	""" Change the image on the main screen, for notification awareness. """
	self.itakaLogo.set_from_file(os.path.join(image_dir, "itaka.png"))
	# Only run this event once
	return False

    def talk(self, action, data1, data2, data3):
        """ Handler for communcations between the classes. """
        #self.cout.debug(["Gui", "talk"], "notified interface. Served:" + str(data1) + " IP: " + str(data2) + " Action: " + action + "")
	if (ialert): self.astring = "\a"
	if (imethod == 'server'):
		self.cout.msg(self.astring + "Screenshot " + str(data1) + " served to: " + str(data2))
	
        if ( action == "updateGuiStatus" ):
            # Update the label on the GUI (show)
            self.labelServed.set_text("Served: " + str(data1))
	    # FIXME: FTP Comaptibility
	    if (data2):
		    self.labelLastip.set_text("IP: " + str(data2))
	    else:
		    self.labelLastip.set_text("Uploaded to FTP")
	    # Call the update Time function, and add a timer
	    self.calcsince(data3)
	
	    # Delete the timer if its Not False
	    # so we dont get duplicates
	    if hasattr(self, 'iagotimer'): gobject.source_remove(self.iagotimer)

	    self.iagotimer = gobject.timeout_add(60000, self.calcsince, data3)
            	    
	    # Notify the main interface
	    if not inotify:
	    	self.itakaLogo.set_from_file(os.path.join(image_dir, "itaka-take.png"))
		self.inotifyimg = gobject.timeout_add(2000, self.notify)
		    
# Start the GTK reactor
try:
	igui = Gui()
	igui.main()
except AttributeError:
	print "[*] ERROR: Gui()"
	traceback.print_exc()
	sys.exit(1)
